<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>openCV人脸识别（从电脑摄像头获取图像）</title>
    <url>/posts/33329d65.html</url>
    <content><![CDATA[<p>openCV人脸识别（从电脑摄像头获取图像）</p>
<h1 id="首先安装openCV-Python库"><a href="#首先安装openCV-Python库" class="headerlink" title="首先安装openCV-Python库"></a>首先安装openCV-Python库</h1><p>使用pycharm作为执行软件</p>
<p><img src="/images/pasted-12.png"></p>
<p><img src="/images/pasted-13.png"></p>
<h1 id="Haar级联检测器"><a href="#Haar级联检测器" class="headerlink" title="Haar级联检测器"></a>Haar级联检测器</h1><p>找到OpenCV根目录下的data/haarcascades文件夹下包含了所有OpenCV的人脸检测的XML文件，这些文件可以用于检测静止图像、视频以及摄像头所得到的图像中的人脸。</p>
<p><img src="/images/pasted-14.png"></p>
<h1 id="我们先选择识别一张静态图像"><a href="#我们先选择识别一张静态图像" class="headerlink" title="我们先选择识别一张静态图像"></a>我们先选择识别一张静态图像</h1><p>识别的图像要保存至Haar级联检测器相同路径！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义图片</span></span><br><span class="line">filename = <span class="string">&#x27;D:/pycharm/my pycharm/venv/Lib/site-packages/cv2/data/c1.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载人脸检测相关的pre-trained分类器，级联检测器</span></span><br><span class="line">face_cascade = cv2.CascadeClassifier(<span class="string">&#x27;D:/pycharm/my pycharm/venv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取图像</span></span><br><span class="line">img = cv2.imread(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">#转为灰度图片</span></span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#人脸检测，第二个参数是移动距离，第三个参数是识别度，越大识别度越高</span></span><br><span class="line">faces = face_cascade.detectMultiScale(gray,1.05,10)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画方框</span></span><br><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(img,(x,y),(x+w,y+w),(0,255,0),2)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;face&#x27;</span>,cv2.WINDOW_KEEPRATIO)<span class="comment">#图像框可以拉动</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;face&#x27;</span>,img)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;face.jpg&#x27;</span>,img)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-15.png"></p>
<p>如果发现人脸没有被识别出来，可以根据情况调节detectMultiScale函数的第二个参数scaleFactor，它表示人脸检测过程中每次迭代时图像的压缩率。</p>
<h1 id="再试试通过摄像头获取图像"><a href="#再试试通过摄像头获取图像" class="headerlink" title="再试试通过摄像头获取图像"></a>再试试通过摄像头获取图像</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启电脑0号摄像头，捕捉图像</span></span><br><span class="line"><span class="built_in">cap</span> = cv2.VideoCapture(0)</span><br><span class="line"><span class="comment">#从摄像头获取图像，第一个为布尔变量表示成功与否，第二个变量是图像</span></span><br><span class="line">ret,filename = cap.read()</span><br><span class="line"><span class="comment">#保存图像至Haar相同路径</span></span><br><span class="line">cv2.imwrite(<span class="string">&#x27;D:/pycharm/my pycharm/venv/Lib/site-packages/cv2/data/c1.jpg&#x27;</span>,filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">#释放摄像头资源</span></span><br><span class="line">cap.release()</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义图片</span></span><br><span class="line">filename = <span class="string">&#x27;D:/pycharm/my pycharm/venv/Lib/site-packages/cv2/data/c1.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载人脸检测相关的pre-trained分类器，级联检测器</span></span><br><span class="line">face_cascade = cv2.CascadeClassifier(<span class="string">&#x27;D:/pycharm/my pycharm/venv/Lib/site-packages/cv2/data/haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取图像</span></span><br><span class="line">img = cv2.imread(filename)</span><br><span class="line"></span><br><span class="line"><span class="comment">#转为灰度图片</span></span><br><span class="line">gray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#人脸检测，第二个参数是移动距离，第三个参数是识别度，越大识别度越高</span></span><br><span class="line">faces = face_cascade.detectMultiScale(gray,1.05,10)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画方框</span></span><br><span class="line"><span class="keyword">for</span> (x,y,w,h) <span class="keyword">in</span> faces:</span><br><span class="line">    cv2.rectangle(img,(x,y),(x+w,y+w),(0,255,0),2)</span><br><span class="line"></span><br><span class="line">cv2.namedWindow(<span class="string">&#x27;face&#x27;</span>,cv2.WINDOW_KEEPRATIO)<span class="comment">#图像框可以拉动</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;face&#x27;</span>,img)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;face.jpg&#x27;</span>,img)</span><br><span class="line">cv2.waitKey(0)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>其会通过摄像头拍摄一张照片，存放到本地，并调用其进行识别，结果将会显示出来。</p>
]]></content>
      <tags>
        <tag>openCV</tag>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>使用arduino输出QMC5883L的三轴磁场和YAW角</title>
    <url>/posts/a012d6f7.html</url>
    <content><![CDATA[<p>通过IIC输出三轴磁力原始数据<br>通过MechaQMC5883库输出yaw角<br>我找了不少关于QMC磁力计的文章，发现不管是商家给的程序还是博客的其他文章，都是基于stm32的，而QMC在arduino上的应用却没多少，于是就一边看着数据文档，一边在arduino上实现QMC。</p>
<p>这里用的是arduino nano,</p>
<p>引脚连接：</p>
<p>nano -&gt; QMC</p>
<p>5V -&gt; VCC</p>
<p>A5 -&gt; SCL</p>
<p>A4 -&gt; SDA</p>
<p>GND -&gt; GND</p>
<p>首先在例程中找到I2C_scanner,打开，连接QMC，上传。</p>
<p><img src="/images/pasted-7.png"></p>
<p>如果没有这个例程，这里给出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// --------------------------------------</span><br><span class="line">// i2c_scanner</span><br><span class="line">//</span><br><span class="line">// Version 1</span><br><span class="line">//    This program (or code that looks like it)</span><br><span class="line">//    can be found <span class="keyword">in</span> many places.</span><br><span class="line">//    For example on the Arduino.cc forum.</span><br><span class="line">//    The original author is not know.</span><br><span class="line">// Version 2, Juni 2012, Using Arduino 1.0.1</span><br><span class="line">//     Adapted to be as simple as possible by Arduino.cc user Krodal</span><br><span class="line">// Version 3, Feb 26  2013</span><br><span class="line">//    V3 by louarnold</span><br><span class="line">// Version 4, March 3, 2013, Using Arduino 1.0.3</span><br><span class="line">//    by Arduino.cc user Krodal.</span><br><span class="line">//    Changes by louarnold removed.</span><br><span class="line">//    Scanning addresses changed from 0...127 to 1...119,</span><br><span class="line">//    according to the i2c scanner by Nick Gammon</span><br><span class="line">//    https://www.gammon.com.au/forum/?id=10896</span><br><span class="line">// Version 5, March 28, 2013</span><br><span class="line">//    As version 4, but address scans now to 127.</span><br><span class="line">//    A sensor seems to use address 120.</span><br><span class="line">// Version 6, November 27, 2015.</span><br><span class="line">//    Added waiting <span class="keyword">for</span> the Leonardo serial communication.</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">// This sketch tests the standard 7-bit addresses</span><br><span class="line">// Devices with higher bit address might not be seen properly.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;Wire.h&gt;</span></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">setup</span></span>() &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line"></span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  <span class="keyword">while</span> (!Serial); // Leonardo: <span class="built_in">wait</span> <span class="keyword">for</span> serial monitor</span><br><span class="line">  Serial.println(<span class="string">&quot;\nI2C Scanner&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">loop</span></span>() &#123;</span><br><span class="line">  int nDevices = 0;</span><br><span class="line"></span><br><span class="line">  Serial.println(<span class="string">&quot;Scanning...&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (byte address = 1; address &lt; 127; ++address) &#123;</span><br><span class="line">    // The i2c_scanner uses the <span class="built_in">return</span> value of</span><br><span class="line">    // the Write.endTransmisstion to see <span class="keyword">if</span></span><br><span class="line">    // a device did acknowledge to the address.</span><br><span class="line">    Wire.beginTransmission(address);</span><br><span class="line">    byte error = Wire.endTransmission();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == 0) &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;I2C device found at address 0x&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (address &lt; 16) &#123;</span><br><span class="line">        Serial.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Serial.print(address, HEX);</span><br><span class="line">      Serial.println(<span class="string">&quot;  !&quot;</span>);</span><br><span class="line"></span><br><span class="line">      ++nDevices;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == 4) &#123;</span><br><span class="line">      Serial.print(<span class="string">&quot;Unknown error at address 0x&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (address &lt; 16) &#123;</span><br><span class="line">        Serial.print(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Serial.println(address, HEX);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nDevices == 0) &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;No I2C devices found\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;done\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  delay(5000); // Wait 5 seconds <span class="keyword">for</span> next scan</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上传后，打开串口监视器，可以看见QMC的地址</p>
<p><img src="/images/pasted-8.png"></p>
<p>然后编写程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;Wire.h&gt;           //使用IIC库</span></span><br><span class="line"><span class="comment">#define address 0x0D        //QMC5883L的设备地址设置</span></span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">setup</span></span>()&#123;</span><br><span class="line">  Serial.begin(9600);  //初始化串口和I2C口</span><br><span class="line">  Wire.begin();</span><br><span class="line">//初始化模块</span><br><span class="line">  Wire.beginTransmission(address);</span><br><span class="line">  Wire.write(0x09); //选择控制寄存器0X09</span><br><span class="line">  Wire.write(0x1D); //设置0x09寄存器为：OSR:512Hz，RNG：+/-8Gauss，ODG：200Hz，MODE：连续工作模式</span><br><span class="line">  Wire.endTransmission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">loop</span></span>()&#123;</span><br><span class="line"></span><br><span class="line">  int x,y,z; //triple axis data</span><br><span class="line"></span><br><span class="line">  Wire.beginTransmission(address);//读写开始</span><br><span class="line">  Wire.write(0x00); //选择X,Y，Z所在数据储存寄存器</span><br><span class="line">  Wire.endTransmission();</span><br><span class="line"></span><br><span class="line">//读取X、Y、Z三个方向的坐标值</span><br><span class="line">  Wire.requestFrom(address, 6);</span><br><span class="line">  <span class="keyword">if</span>(6&lt;=Wire.available())&#123;</span><br><span class="line">    x = Wire.read()&lt;&lt;<span class="string">8; //X msb</span></span><br><span class="line"><span class="string">    x |= Wire.read(); //X lsb</span></span><br><span class="line"><span class="string">    z = Wire.read()&lt;&lt;8</span>; //Z msb</span><br><span class="line">    z |= Wire.read(); //Z lsb</span><br><span class="line">    y = Wire.read()&lt;&lt;<span class="string">8; //Y msb</span></span><br><span class="line"><span class="string">    y |= Wire.read(); //Y lsb</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">//打印坐标到串口</span></span><br><span class="line"><span class="string">  Serial.print(&quot;x: &quot;);</span></span><br><span class="line"><span class="string">  Serial.print(x);</span></span><br><span class="line"><span class="string">  Serial.print(&quot;  y: &quot;);</span></span><br><span class="line"><span class="string">  Serial.print(y);</span></span><br><span class="line"><span class="string">  Serial.print(&quot;  z: &quot;);</span></span><br><span class="line"><span class="string">  Serial.println(z);</span></span><br><span class="line"><span class="string">  delay(100);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>这里会输出三轴磁力数据：</p>
<p><img src="/images/pasted-9.png"></p>
<p>但这些还没有转为角度，使用下面这个链接中的库转为yaw角：</p>
<p><a href="https://github.com/keepworking/Mecha_QMC5883L">https://github.com/keepworking/Mecha_QMC5883L</a></p>
<p>下载这个库，并保存至你的arduino库位置中：</p>
<p>…\Arduino\libraries</p>
<p>将文件名修改为MechaQMC5883</p>
<p>编写以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;Wire.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;MechaQMC5883.h&gt;</span></span><br><span class="line"></span><br><span class="line">MechaQMC5883 qmc;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">setup</span></span>() &#123;</span><br><span class="line">  Wire.begin();</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  qmc.init();</span><br><span class="line">  //qmc.setMode(Mode_Continuous,ODR_200Hz,RNG_2G,OSR_256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">loop</span></span>() &#123;</span><br><span class="line">  int x,y,z;</span><br><span class="line">  int yaw;</span><br><span class="line">  qmc.read(&amp;x,&amp;y,&amp;z);</span><br><span class="line">  yaw = qmc.azimuth(&amp;y,&amp;x);</span><br><span class="line"></span><br><span class="line">  Serial.print(<span class="string">&quot;x: &quot;</span>);</span><br><span class="line">  Serial.print(x);</span><br><span class="line">  Serial.print(<span class="string">&quot; y: &quot;</span>);</span><br><span class="line">  Serial.print(y);</span><br><span class="line">  Serial.print(<span class="string">&quot; z: &quot;</span>);</span><br><span class="line">  Serial.print(z);</span><br><span class="line">  Serial.print(<span class="string">&quot; yaw: &quot;</span>);</span><br><span class="line">  Serial.print(yaw);</span><br><span class="line">  Serial.println();</span><br><span class="line">  delay(100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上传，打开串口监视器：</p>
<p><img src="/images/pasted-10.png"></p>
<p>已经输出yaw角！</p>
]]></content>
      <tags>
        <tag>arduino</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于hexo 首页图片无法显示解决方法</title>
    <url>/posts/428be35.html</url>
    <content><![CDATA[<p><img src="/images/pasted-6.png" alt="upload successful"></p>
<p>有时Markdown可以显示图片，而上传hexo后无法显示图片，只要在Markdown的图片显示链接中将“\”修改为“/”，同时删除第一个和最后一个“\”</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<p>修改为</p>
<p><img src="/images/pasted-4.png" alt="upload successful"></p>
<p>即可显示在hexo</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>上传图片</title>
    <url>/posts/bd55ecf0.html</url>
    <content><![CDATA[<p>试用Mardown上传图片</p>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>picture</tag>
      </tags>
  </entry>
</search>
